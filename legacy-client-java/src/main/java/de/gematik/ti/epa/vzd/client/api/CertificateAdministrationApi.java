/*
 * I_Directory_Administration
 * REST Schnittstelle zur Pflege der Verzeichniseinträge. Über diese Schnittstelle können Verzeichniseinträge inklusive Zertifikaten erzeugt, aktualisiert und gelöscht werden. Die Administration von Fachdaten erfolgt über Schnittstelle I_Directory_Application_Maintenance und wird durch die Fachanwendungen durchgeführt. Lesender Zugriff auf die Fachdaten ist mit Operation getDirectoryEntries in vorliegender Schnittstelle möglich.
 *
 * The version of the OpenAPI document: 1.6.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package de.gematik.ti.epa.vzd.client.api;

import com.google.gson.reflect.TypeToken;
import de.gematik.ti.epa.vzd.client.invoker.*;
import de.gematik.ti.epa.vzd.client.model.DistinguishedName;
import de.gematik.ti.epa.vzd.client.model.UserCertificate;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CertificateAdministrationApi {

  private ApiClient localVarApiClient;

  public CertificateAdministrationApi() {
    this(Configuration.getDefaultApiClient());
  }

  public CertificateAdministrationApi(ApiClient apiClient) {
    this.localVarApiClient = apiClient;
  }

  public ApiClient getApiClient() {
    return localVarApiClient;
  }

  public void setApiClient(ApiClient apiClient) {
    this.localVarApiClient = apiClient;
  }

  /**
   * Build call for addDirectoryEntryCertificate
   *
   * @param uid             ID (dn.uid) vom übergeordneten Verzeichniseintrag (required)
   * @param userCertificate Datensatz für die Erzeugung des Eintrags Die Attribute müssen wie folgt
   *                        belegt sein Attribut          Wert -------------------------------------------
   *                        dn.*              Nicht vorhanden (Adressierung erfolgt über uid in
   *                        Path) telematikID       Kann optional belegt werden. Wird telematikID
   *                        angegeben, dann muss diese telematikID mit der telematikID im
   *                        userCertificate übereinstimmen. Die telematikID muss mit der telematikID
   *                        in den Basisdaten (baseDirectoryEntry) übereinstimmen (falls dort
   *                        angegeben). Falls die telematikID in den Basisdaten (baseDirectoryEntry)
   *                        leer ist, muss sie auf den Wert aus dem Zertifikat bzw. dem hier
   *                        angegebenen Wert gesetzt werden. Bei unterschiedlichen telematikIDs wird
   *                        die Operation mit Fehlercode 422 abgelehnt. entryType         Nicht
   *                        vorhanden (wird vom Verzeichnisdienst belegt) professionOID     Nicht
   *                        vorhanden (wird vom Verzeichnisdienst belegt) usage             Kann
   *                        optional belegt werden userCertificate   Muss vorhanden sein description
   *                        Kann optional belegt werden (required)
   * @param _callback       Callback for upload/download progress
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call addDirectoryEntryCertificateCall(String uid, UserCertificate userCertificate,
      final ApiCallback _callback)
      throws ApiException {
    Object localVarPostBody = userCertificate;

    // create path and map variables
    String localVarPath = "/DirectoryEntries/{uid}/Certificates"
        .replaceAll("\\{" + "uid" + "\\}", localVarApiClient.escapeString(uid.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();
    final String[] localVarAccepts = {
        "application/json"
    };
    final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) {
      localVarHeaderParams.put("Accept", localVarAccept);
    }

    final String[] localVarContentTypes = {
        "application/json"
    };
    final String localVarContentType = localVarApiClient.selectHeaderContentType(
        localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    String[] localVarAuthNames = new String[]{"OAuth2"};
    return localVarApiClient
        .buildCall(localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams,
            localVarPostBody, localVarHeaderParams,
            localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
  }

  @SuppressWarnings("rawtypes")
  private okhttp3.Call addDirectoryEntryCertificateValidateBeforeCall(String uid,
      UserCertificate userCertificate, final ApiCallback _callback)
      throws ApiException {

    // verify the required parameter 'uid' is set
    if (uid == null) {
      throw new ApiException(
          "Missing the required parameter 'uid' when calling addDirectoryEntryCertificate(Async)");
    }

    // verify the required parameter 'userCertificate' is set
    if (userCertificate == null) {
      throw new ApiException(
          "Missing the required parameter 'userCertificate' when calling addDirectoryEntryCertificate(Async)");
    }

    okhttp3.Call localVarCall = addDirectoryEntryCertificateCall(uid, userCertificate, _callback);
    return localVarCall;

  }

  /**
   * Der Zertifikatseintrag wird im Verzeichnisdienst hinzugefügt und ist logisch über dn.uid mit
   * dem übergeordneten Verzeichniseintrag verknüpft.
   *
   * @param uid             ID (dn.uid) vom übergeordneten Verzeichniseintrag (required)
   * @param userCertificate Datensatz für die Erzeugung des Eintrags Die Attribute müssen wie folgt
   *                        belegt sein Attribut          Wert -------------------------------------------
   *                        dn.*              Nicht vorhanden (Adressierung erfolgt über uid in
   *                        Path) telematikID       Kann optional belegt werden. Wird telematikID
   *                        angegeben, dann muss diese telematikID mit der telematikID im
   *                        userCertificate übereinstimmen. Die telematikID muss mit der telematikID
   *                        in den Basisdaten (baseDirectoryEntry) übereinstimmen (falls dort
   *                        angegeben). Falls die telematikID in den Basisdaten (baseDirectoryEntry)
   *                        leer ist, muss sie auf den Wert aus dem Zertifikat bzw. dem hier
   *                        angegebenen Wert gesetzt werden. Bei unterschiedlichen telematikIDs wird
   *                        die Operation mit Fehlercode 422 abgelehnt. entryType         Nicht
   *                        vorhanden (wird vom Verzeichnisdienst belegt) professionOID     Nicht
   *                        vorhanden (wird vom Verzeichnisdienst belegt) usage             Kann
   *                        optional belegt werden userCertificate   Muss vorhanden sein description
   *                        Kann optional belegt werden (required)
   * @return DistinguishedName
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public DistinguishedName addDirectoryEntryCertificate(String uid, UserCertificate userCertificate)
      throws ApiException {
    ApiResponse<DistinguishedName> localVarResp = addDirectoryEntryCertificateWithHttpInfo(uid,
        userCertificate);
    return localVarResp.getData();
  }

  /**
   * Der Zertifikatseintrag wird im Verzeichnisdienst hinzugefügt und ist logisch über dn.uid mit
   * dem übergeordneten Verzeichniseintrag verknüpft.
   *
   * @param uid             ID (dn.uid) vom übergeordneten Verzeichniseintrag (required)
   * @param userCertificate Datensatz für die Erzeugung des Eintrags Die Attribute müssen wie folgt
   *                        belegt sein Attribut          Wert -------------------------------------------
   *                        dn.*              Nicht vorhanden (Adressierung erfolgt über uid in
   *                        Path) telematikID       Kann optional belegt werden. Wird telematikID
   *                        angegeben, dann muss diese telematikID mit der telematikID im
   *                        userCertificate übereinstimmen. Die telematikID muss mit der telematikID
   *                        in den Basisdaten (baseDirectoryEntry) übereinstimmen (falls dort
   *                        angegeben). Falls die telematikID in den Basisdaten (baseDirectoryEntry)
   *                        leer ist, muss sie auf den Wert aus dem Zertifikat bzw. dem hier
   *                        angegebenen Wert gesetzt werden. Bei unterschiedlichen telematikIDs wird
   *                        die Operation mit Fehlercode 422 abgelehnt. entryType         Nicht
   *                        vorhanden (wird vom Verzeichnisdienst belegt) professionOID     Nicht
   *                        vorhanden (wird vom Verzeichnisdienst belegt) usage             Kann
   *                        optional belegt werden userCertificate   Muss vorhanden sein description
   *                        Kann optional belegt werden (required)
   * @return ApiResponse&lt;DistinguishedName&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public ApiResponse<DistinguishedName> addDirectoryEntryCertificateWithHttpInfo(String uid,
      UserCertificate userCertificate) throws ApiException {
    okhttp3.Call localVarCall = addDirectoryEntryCertificateValidateBeforeCall(uid, userCertificate,
        null);
    Type localVarReturnType = new TypeToken<DistinguishedName>() {
    }.getType();
    return localVarApiClient.execute(localVarCall, localVarReturnType);
  }

  /**
   * Der Zertifikatseintrag wird im Verzeichnisdienst hinzugefügt und ist logisch über dn.uid mit
   * dem übergeordneten Verzeichniseintrag verknüpft. (asynchronously)
   *
   * @param uid             ID (dn.uid) vom übergeordneten Verzeichniseintrag (required)
   * @param userCertificate Datensatz für die Erzeugung des Eintrags Die Attribute müssen wie folgt
   *                        belegt sein Attribut          Wert -------------------------------------------
   *                        dn.*              Nicht vorhanden (Adressierung erfolgt über uid in
   *                        Path) telematikID       Kann optional belegt werden. Wird telematikID
   *                        angegeben, dann muss diese telematikID mit der telematikID im
   *                        userCertificate übereinstimmen. Die telematikID muss mit der telematikID
   *                        in den Basisdaten (baseDirectoryEntry) übereinstimmen (falls dort
   *                        angegeben). Falls die telematikID in den Basisdaten (baseDirectoryEntry)
   *                        leer ist, muss sie auf den Wert aus dem Zertifikat bzw. dem hier
   *                        angegebenen Wert gesetzt werden. Bei unterschiedlichen telematikIDs wird
   *                        die Operation mit Fehlercode 422 abgelehnt. entryType         Nicht
   *                        vorhanden (wird vom Verzeichnisdienst belegt) professionOID     Nicht
   *                        vorhanden (wird vom Verzeichnisdienst belegt) usage             Kann
   *                        optional belegt werden userCertificate   Muss vorhanden sein description
   *                        Kann optional belegt werden (required)
   * @param _callback       The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call addDirectoryEntryCertificateAsync(String uid, UserCertificate userCertificate,
      final ApiCallback<DistinguishedName> _callback)
      throws ApiException {

    okhttp3.Call localVarCall = addDirectoryEntryCertificateValidateBeforeCall(uid, userCertificate,
        _callback);
    Type localVarReturnType = new TypeToken<DistinguishedName>() {
    }.getType();
    localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
    return localVarCall;
  }

  /**
   * Build call for deleteDirectoryEntryCertificate
   *
   * @param uid                ID vom übergeordneten Verzeichniseintrag (required)
   * @param certificateEntryID ID von dem zu löschenden Zertifikatseintrag (required)
   * @param _callback          Callback for upload/download progress
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call deleteDirectoryEntryCertificateCall(String uid, String certificateEntryID,
      final ApiCallback _callback) throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/DirectoryEntries/{uid}/Certificates/{certificateEntryID}"
        .replaceAll("\\{" + "uid" + "\\}", localVarApiClient.escapeString(uid.toString()))
        .replaceAll("\\{" + "certificateEntryID" + "\\}",
            localVarApiClient.escapeString(certificateEntryID.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();
    final String[] localVarAccepts = {
        "application/json"
    };
    final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) {
      localVarHeaderParams.put("Accept", localVarAccept);
    }

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = localVarApiClient.selectHeaderContentType(
        localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    String[] localVarAuthNames = new String[]{"OAuth2"};
    return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams,
        localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams,
        localVarFormParams, localVarAuthNames, _callback);
  }

  @SuppressWarnings("rawtypes")
  private okhttp3.Call deleteDirectoryEntryCertificateValidateBeforeCall(String uid,
      String certificateEntryID, final ApiCallback _callback) throws ApiException {

    // verify the required parameter 'uid' is set
    if (uid == null) {
      throw new ApiException(
          "Missing the required parameter 'uid' when calling deleteDirectoryEntryCertificate(Async)");
    }

    // verify the required parameter 'certificateEntryID' is set
    if (certificateEntryID == null) {
      throw new ApiException(
          "Missing the required parameter 'certificateEntryID' when calling deleteDirectoryEntryCertificate(Async)");
    }

    okhttp3.Call localVarCall = deleteDirectoryEntryCertificateCall(uid, certificateEntryID,
        _callback);
    return localVarCall;

  }

  /**
   * Zertifikatseintrag löschen Dem Verzeichniseintrag muss immer mindestens ein Zertifikat
   * zugeordnet sein. Wenn nach dem Löschen kein Zertifikat mehr dem Verzeichniseintrag zugeordnet
   * wäre, muss die delete Operation abgelehnt werden.
   *
   * @param uid                ID vom übergeordneten Verzeichniseintrag (required)
   * @param certificateEntryID ID von dem zu löschenden Zertifikatseintrag (required)
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
   * </table>
   */
  public void deleteDirectoryEntryCertificate(String uid, String certificateEntryID)
      throws ApiException {
    deleteDirectoryEntryCertificateWithHttpInfo(uid, certificateEntryID);
  }

  /**
   * Zertifikatseintrag löschen Dem Verzeichniseintrag muss immer mindestens ein Zertifikat
   * zugeordnet sein. Wenn nach dem Löschen kein Zertifikat mehr dem Verzeichniseintrag zugeordnet
   * wäre, muss die delete Operation abgelehnt werden.
   *
   * @param uid                ID vom übergeordneten Verzeichniseintrag (required)
   * @param certificateEntryID ID von dem zu löschenden Zertifikatseintrag (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
   * </table>
   */
  public ApiResponse<Void> deleteDirectoryEntryCertificateWithHttpInfo(String uid,
      String certificateEntryID) throws ApiException {
    okhttp3.Call localVarCall = deleteDirectoryEntryCertificateValidateBeforeCall(uid,
        certificateEntryID, null);
    return localVarApiClient.execute(localVarCall);
  }

  /**
   * Zertifikatseintrag löschen Dem Verzeichniseintrag muss immer mindestens ein Zertifikat
   * zugeordnet sein. Wenn nach dem Löschen kein Zertifikat mehr dem Verzeichniseintrag zugeordnet
   * wäre, muss die delete Operation abgelehnt werden. (asynchronously)
   *
   * @param uid                ID vom übergeordneten Verzeichniseintrag (required)
   * @param certificateEntryID ID von dem zu löschenden Zertifikatseintrag (required)
   * @param _callback          The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * <tr><td> 409 </td><td> Conflict </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call deleteDirectoryEntryCertificateAsync(String uid, String certificateEntryID,
      final ApiCallback<Void> _callback) throws ApiException {

    okhttp3.Call localVarCall = deleteDirectoryEntryCertificateValidateBeforeCall(uid,
        certificateEntryID, _callback);
    localVarApiClient.executeAsync(localVarCall, _callback);
    return localVarCall;
  }

  /**
   * Build call for readDirectoryCertificates
   *
   * @param uid                ID vom übergeordneten Verzeichniseintrag (optional)
   * @param certificateEntryID ID von dem Zertifikat (dn.cn vom Zertifikatseintrag) Wenn angegeben
   *                           wird das adressierte (certificateEntryID) Zertifikat geliefert. Wenn
   *                           nicht angegeben werden alle Zertifikate des übergeordneten
   *                           Verzeichniseintrags geliefert. (optional)
   * @param entryType          Erlaubt die Suche mit Hilfe des Attributs entryType. (optional)
   * @param telematikID        telematikID von dem Zertifikat Erlaubt die Suche nach
   *                           Zertifikatseinträgen einer telematikID. (optional)
   * @param professionOID      Erlaubt die Suche mit Hilfe des Attributs professionOID. Der
   *                           Verzeichniseintrag wird selektiert, wenn die angegebene professionOID
   *                           im Attribut professionOID (array) des Zertifikatseintrags enthalten
   *                           ist. (optional)
   * @param usage              Erlaubt die Suche mit Hilfe des Attributs usage. Der
   *                           Verzeichniseintrag wird selektiert, wenn die angegebene usage im
   *                           Attribut usage (array) des Zertifikatseintrags enthalten ist.
   *                           (optional)
   * @param _callback          Callback for upload/download progress
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call readDirectoryCertificatesCall(String uid, String certificateEntryID,
      String entryType, String telematikID,
      String professionOID, String usage, final ApiCallback _callback) throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/DirectoryEntries/Certificates";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (uid != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("uid", uid));
    }

    if (certificateEntryID != null) {
      localVarQueryParams.addAll(
          localVarApiClient.parameterToPair("certificateEntryID", certificateEntryID));
    }

    if (entryType != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("entryType", entryType));
    }

    if (telematikID != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("telematikID", telematikID));
    }

    if (professionOID != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("professionOID", professionOID));
    }

    if (usage != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("usage", usage));
    }

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();
    final String[] localVarAccepts = {
        "application/json"
    };
    final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) {
      localVarHeaderParams.put("Accept", localVarAccept);
    }

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = localVarApiClient.selectHeaderContentType(
        localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    String[] localVarAuthNames = new String[]{"OAuth2"};
    return localVarApiClient
        .buildCall(localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams,
            localVarPostBody, localVarHeaderParams,
            localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
  }

  @SuppressWarnings("rawtypes")
  private okhttp3.Call readDirectoryCertificatesValidateBeforeCall(String uid,
      String certificateEntryID, String entryType, String telematikID,
      String professionOID, String usage, final ApiCallback _callback) throws ApiException {

    okhttp3.Call localVarCall = readDirectoryCertificatesCall(uid, certificateEntryID, entryType,
        telematikID, professionOID, usage, _callback);
    return localVarCall;

  }

  /**
   * Zertifikat lesen Liefert alle Zertifikate, die dem Filter (siehe &#39;parameters&#39;)
   * entsprechen.
   *
   * @param uid                ID vom übergeordneten Verzeichniseintrag (optional)
   * @param certificateEntryID ID von dem Zertifikat (dn.cn vom Zertifikatseintrag) Wenn angegeben
   *                           wird das adressierte (certificateEntryID) Zertifikat geliefert. Wenn
   *                           nicht angegeben werden alle Zertifikate des übergeordneten
   *                           Verzeichniseintrags geliefert. (optional)
   * @param entryType          Erlaubt die Suche mit Hilfe des Attributs entryType. (optional)
   * @param telematikID        telematikID von dem Zertifikat Erlaubt die Suche nach
   *                           Zertifikatseinträgen einer telematikID. (optional)
   * @param professionOID      Erlaubt die Suche mit Hilfe des Attributs professionOID. Der
   *                           Verzeichniseintrag wird selektiert, wenn die angegebene professionOID
   *                           im Attribut professionOID (array) des Zertifikatseintrags enthalten
   *                           ist. (optional)
   * @param usage              Erlaubt die Suche mit Hilfe des Attributs usage. Der
   *                           Verzeichniseintrag wird selektiert, wenn die angegebene usage im
   *                           Attribut usage (array) des Zertifikatseintrags enthalten ist.
   *                           (optional)
   * @return List&lt;UserCertificate&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public List<UserCertificate> readDirectoryCertificates(String uid, String certificateEntryID,
      String entryType, String telematikID,
      String professionOID, String usage) throws ApiException {
    ApiResponse<List<UserCertificate>> localVarResp = readDirectoryCertificatesWithHttpInfo(uid,
        certificateEntryID, entryType, telematikID,
        professionOID, usage);
    return localVarResp.getData();
  }

  /**
   * Zertifikat lesen Liefert alle Zertifikate, die dem Filter (siehe &#39;parameters&#39;)
   * entsprechen.
   *
   * @param uid                ID vom übergeordneten Verzeichniseintrag (optional)
   * @param certificateEntryID ID von dem Zertifikat (dn.cn vom Zertifikatseintrag) Wenn angegeben
   *                           wird das adressierte (certificateEntryID) Zertifikat geliefert. Wenn
   *                           nicht angegeben werden alle Zertifikate des übergeordneten
   *                           Verzeichniseintrags geliefert. (optional)
   * @param entryType          Erlaubt die Suche mit Hilfe des Attributs entryType. (optional)
   * @param telematikID        telematikID von dem Zertifikat Erlaubt die Suche nach
   *                           Zertifikatseinträgen einer telematikID. (optional)
   * @param professionOID      Erlaubt die Suche mit Hilfe des Attributs professionOID. Der
   *                           Verzeichniseintrag wird selektiert, wenn die angegebene professionOID
   *                           im Attribut professionOID (array) des Zertifikatseintrags enthalten
   *                           ist. (optional)
   * @param usage              Erlaubt die Suche mit Hilfe des Attributs usage. Der
   *                           Verzeichniseintrag wird selektiert, wenn die angegebene usage im
   *                           Attribut usage (array) des Zertifikatseintrags enthalten ist.
   *                           (optional)
   * @return ApiResponse&lt;List&lt;UserCertificate&gt;&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public ApiResponse<List<UserCertificate>> readDirectoryCertificatesWithHttpInfo(String uid,
      String certificateEntryID, String entryType,
      String telematikID, String professionOID, String usage) throws ApiException {
    okhttp3.Call localVarCall = readDirectoryCertificatesValidateBeforeCall(uid, certificateEntryID,
        entryType, telematikID, professionOID, usage,
        null);
    Type localVarReturnType = new TypeToken<List<UserCertificate>>() {
    }.getType();
    return localVarApiClient.execute(localVarCall, localVarReturnType);
  }

  /**
   * Zertifikat lesen (asynchronously) Liefert alle Zertifikate, die dem Filter (siehe
   * &#39;parameters&#39;) entsprechen.
   *
   * @param uid                ID vom übergeordneten Verzeichniseintrag (optional)
   * @param certificateEntryID ID von dem Zertifikat (dn.cn vom Zertifikatseintrag) Wenn angegeben
   *                           wird das adressierte (certificateEntryID) Zertifikat geliefert. Wenn
   *                           nicht angegeben werden alle Zertifikate des übergeordneten
   *                           Verzeichniseintrags geliefert. (optional)
   * @param entryType          Erlaubt die Suche mit Hilfe des Attributs entryType. (optional)
   * @param telematikID        telematikID von dem Zertifikat Erlaubt die Suche nach
   *                           Zertifikatseinträgen einer telematikID. (optional)
   * @param professionOID      Erlaubt die Suche mit Hilfe des Attributs professionOID. Der
   *                           Verzeichniseintrag wird selektiert, wenn die angegebene professionOID
   *                           im Attribut professionOID (array) des Zertifikatseintrags enthalten
   *                           ist. (optional)
   * @param usage              Erlaubt die Suche mit Hilfe des Attributs usage. Der
   *                           Verzeichniseintrag wird selektiert, wenn die angegebene usage im
   *                           Attribut usage (array) des Zertifikatseintrags enthalten ist.
   *                           (optional)
   * @param _callback          The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call readDirectoryCertificatesAsync(String uid, String certificateEntryID,
      String entryType, String telematikID,
      String professionOID, String usage, final ApiCallback<List<UserCertificate>> _callback)
      throws ApiException {

    okhttp3.Call localVarCall = readDirectoryCertificatesValidateBeforeCall(uid, certificateEntryID,
        entryType, telematikID, professionOID, usage,
        _callback);
    Type localVarReturnType = new TypeToken<List<UserCertificate>>() {
    }.getType();
    localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
    return localVarCall;
  }
}
