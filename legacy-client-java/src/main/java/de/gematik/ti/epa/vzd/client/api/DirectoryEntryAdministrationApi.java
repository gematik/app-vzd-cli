/*
 * I_Directory_Administration
 * REST Schnittstelle zur Pflege der Verzeichniseinträge. Über diese Schnittstelle können Verzeichniseinträge inklusive Zertifikaten erzeugt, aktualisiert und gelöscht werden. Die Administration von Fachdaten erfolgt über Schnittstelle I_Directory_Application_Maintenance und wird durch die Fachanwendungen durchgeführt. Lesender Zugriff auf die Fachdaten ist mit Operation getDirectoryEntries in vorliegender Schnittstelle möglich.
 *
 * The version of the OpenAPI document: 1.6.3
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package de.gematik.ti.epa.vzd.client.api;

import com.google.gson.reflect.TypeToken;
import de.gematik.ti.epa.vzd.client.invoker.*;
import de.gematik.ti.epa.vzd.client.model.BaseDirectoryEntry;
import de.gematik.ti.epa.vzd.client.model.CreateDirectoryEntry;
import de.gematik.ti.epa.vzd.client.model.DirectoryEntry;
import de.gematik.ti.epa.vzd.client.model.DistinguishedName;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class DirectoryEntryAdministrationApi {

  private ApiClient localVarApiClient;

  public DirectoryEntryAdministrationApi() {
    this(Configuration.getDefaultApiClient());
  }

  public DirectoryEntryAdministrationApi(ApiClient apiClient) {
    this.localVarApiClient = apiClient;
  }

  public ApiClient getApiClient() {
    return localVarApiClient;
  }

  public void setApiClient(ApiClient apiClient) {
    this.localVarApiClient = apiClient;
  }

  /**
   * Build call for addDirectoryEntry
   *
   * @param createDirectoryEntry Datensatz für den neuen Eintrag. Die Attribute müssen wie folgt
   *                             belegt sein dn.*          Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) givenName     Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) sn Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) cn            Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) displayName   Kann optional belegt
   *                             werden. streetAddress Kann optional belegt werden. postalCode
   *                             Kann optional belegt werden. countryCode   Kann optional belegt
   *                             werden. Falls nicht belegt, ergänzt der VZD den Code für
   *                             Deutschland (Defaultwert). localityName  Kann optional belegt
   *                             werden. stateOrProvinceName  Kann optional belegt werden. title
   *                                 Kann optional belegt werden. organization  Kann optional belegt
   *                             werden. otherName     Kann optional belegt werden. telematikID Kann
   *                             optional belegt werden. Das ist die telematikID in den Basisdaten
   *                             (baseDirectoryEntry). Wird diese telematikID und userCertificate
   *                             bzw. die telematikID in userCertificate angegeben, dann müssen
   *                             diese telematikIDs übereinstimmen. Bei unterschiedlichen
   *                             telematikID wird die Operation mit Fehlercode 422 abgelehnt.
   *                             specialization  Kann optional belegt werden. domainID      Kann
   *                             optional belegt werden. holder Kann optional belegt werden (falls
   *                             nicht belegt, dann vom VZD aus dem ID_Token entnommen). maxKOMLEadr
   *                               Kann optional belegt werden. personalEntry Nicht vorhanden (wird
   *                             vom Verzeichnisdienst belegt) dataFromAuthority Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) userCertificates  Kann optional
   *                             belegt werden. dn.uid Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) dn.dc         Leer/nicht vorhanden (wird
   *                             vom Verzeichnisdienst belegt) dn.ou Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst  belegt) dn.cn Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) telematikID   Kann optional belegt
   *                             werden. Wird telematikID und userCertificate angegeben, dann muss
   *                             diese telematikID mit der telematikID im userCertificate
   *                             übereinstimmen. Bei unterschiedlichen telematikID wird die
   *                             Operation mit Fehlercode 422 abgelehnt. entryType Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) professionOID Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) usage         Kann optional
   *                             belegt werden. userCertificate   Kann optional belegt werden
   *                             (Format DER, Base64 kodiert) description   Kann optional belegt
   *                             werden. Entsprechend gemSpec_VZD wird ein Teil der Attribute durch
   *                             den Verzeichnisdienst automatisch mit Werten aus dem Zertifikat
   *                             gefüllt. Wenn in dieser Operation Attribute - für die dies erlaubt
   *                             ist - mit einem Wert belegt werden, wird dieser Wert im
   *                             Verzeichniseintrag gespeichert (auch wenn der Wert durch den
   *                             Verzeichnisdienst aus dem Zertifikat entnommen werden kann).
   *                             (required)
   * @param _callback            Callback for upload/download progress
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call addDirectoryEntryCall(CreateDirectoryEntry createDirectoryEntry,
      final ApiCallback _callback) throws ApiException {
    Object localVarPostBody = createDirectoryEntry;

    // create path and map variables
    String localVarPath = "/DirectoryEntries";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();
    final String[] localVarAccepts = {
        "application/json"
    };
    final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) {
      localVarHeaderParams.put("Accept", localVarAccept);
    }

    final String[] localVarContentTypes = {
        "application/json"
    };
    final String localVarContentType = localVarApiClient.selectHeaderContentType(
        localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    String[] localVarAuthNames = new String[]{"OAuth2"};
    return localVarApiClient.buildCall(localVarPath, "POST", localVarQueryParams,
        localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams,
        localVarFormParams, localVarAuthNames, _callback);
  }

  @SuppressWarnings("rawtypes")
  private okhttp3.Call addDirectoryEntryValidateBeforeCall(
      CreateDirectoryEntry createDirectoryEntry, final ApiCallback _callback) throws ApiException {

    // verify the required parameter 'createDirectoryEntry' is set
    if (createDirectoryEntry == null) {
      throw new ApiException(
          "Missing the required parameter 'createDirectoryEntry' when calling addDirectoryEntry(Async)");
    }

    okhttp3.Call localVarCall = addDirectoryEntryCall(createDirectoryEntry, _callback);
    return localVarCall;

  }

  /**
   * Einen Eintrag zum Verzeichnisdienst hinzufügen
   *
   * @param createDirectoryEntry Datensatz für den neuen Eintrag. Die Attribute müssen wie folgt
   *                             belegt sein dn.*          Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) givenName     Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) sn Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) cn            Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) displayName   Kann optional belegt
   *                             werden. streetAddress Kann optional belegt werden. postalCode
   *                             Kann optional belegt werden. countryCode   Kann optional belegt
   *                             werden. Falls nicht belegt, ergänzt der VZD den Code für
   *                             Deutschland (Defaultwert). localityName  Kann optional belegt
   *                             werden. stateOrProvinceName  Kann optional belegt werden. title
   *                                 Kann optional belegt werden. organization  Kann optional belegt
   *                             werden. otherName     Kann optional belegt werden. telematikID Kann
   *                             optional belegt werden. Das ist die telematikID in den Basisdaten
   *                             (baseDirectoryEntry). Wird diese telematikID und userCertificate
   *                             bzw. die telematikID in userCertificate angegeben, dann müssen
   *                             diese telematikIDs übereinstimmen. Bei unterschiedlichen
   *                             telematikID wird die Operation mit Fehlercode 422 abgelehnt.
   *                             specialization  Kann optional belegt werden. domainID      Kann
   *                             optional belegt werden. holder Kann optional belegt werden (falls
   *                             nicht belegt, dann vom VZD aus dem ID_Token entnommen). maxKOMLEadr
   *                               Kann optional belegt werden. personalEntry Nicht vorhanden (wird
   *                             vom Verzeichnisdienst belegt) dataFromAuthority Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) userCertificates  Kann optional
   *                             belegt werden. dn.uid Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) dn.dc         Leer/nicht vorhanden (wird
   *                             vom Verzeichnisdienst belegt) dn.ou Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst  belegt) dn.cn Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) telematikID   Kann optional belegt
   *                             werden. Wird telematikID und userCertificate angegeben, dann muss
   *                             diese telematikID mit der telematikID im userCertificate
   *                             übereinstimmen. Bei unterschiedlichen telematikID wird die
   *                             Operation mit Fehlercode 422 abgelehnt. entryType Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) professionOID Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) usage         Kann optional
   *                             belegt werden. userCertificate   Kann optional belegt werden
   *                             (Format DER, Base64 kodiert) description   Kann optional belegt
   *                             werden. Entsprechend gemSpec_VZD wird ein Teil der Attribute durch
   *                             den Verzeichnisdienst automatisch mit Werten aus dem Zertifikat
   *                             gefüllt. Wenn in dieser Operation Attribute - für die dies erlaubt
   *                             ist - mit einem Wert belegt werden, wird dieser Wert im
   *                             Verzeichniseintrag gespeichert (auch wenn der Wert durch den
   *                             Verzeichnisdienst aus dem Zertifikat entnommen werden kann).
   *                             (required)
   * @return DistinguishedName
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public DistinguishedName addDirectoryEntry(CreateDirectoryEntry createDirectoryEntry)
      throws ApiException {
    ApiResponse<DistinguishedName> localVarResp = addDirectoryEntryWithHttpInfo(
        createDirectoryEntry);
    return localVarResp.getData();
  }

  /**
   * Einen Eintrag zum Verzeichnisdienst hinzufügen
   *
   * @param createDirectoryEntry Datensatz für den neuen Eintrag. Die Attribute müssen wie folgt
   *                             belegt sein dn.*          Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) givenName     Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) sn Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) cn            Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) displayName   Kann optional belegt
   *                             werden. streetAddress Kann optional belegt werden. postalCode
   *                             Kann optional belegt werden. countryCode   Kann optional belegt
   *                             werden. Falls nicht belegt, ergänzt der VZD den Code für
   *                             Deutschland (Defaultwert). localityName  Kann optional belegt
   *                             werden. stateOrProvinceName  Kann optional belegt werden. title
   *                                 Kann optional belegt werden. organization  Kann optional belegt
   *                             werden. otherName     Kann optional belegt werden. telematikID Kann
   *                             optional belegt werden. Das ist die telematikID in den Basisdaten
   *                             (baseDirectoryEntry). Wird diese telematikID und userCertificate
   *                             bzw. die telematikID in userCertificate angegeben, dann müssen
   *                             diese telematikIDs übereinstimmen. Bei unterschiedlichen
   *                             telematikID wird die Operation mit Fehlercode 422 abgelehnt.
   *                             specialization  Kann optional belegt werden. domainID      Kann
   *                             optional belegt werden. holder Kann optional belegt werden (falls
   *                             nicht belegt, dann vom VZD aus dem ID_Token entnommen). maxKOMLEadr
   *                               Kann optional belegt werden. personalEntry Nicht vorhanden (wird
   *                             vom Verzeichnisdienst belegt) dataFromAuthority Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) userCertificates  Kann optional
   *                             belegt werden. dn.uid Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) dn.dc         Leer/nicht vorhanden (wird
   *                             vom Verzeichnisdienst belegt) dn.ou Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst  belegt) dn.cn Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) telematikID   Kann optional belegt
   *                             werden. Wird telematikID und userCertificate angegeben, dann muss
   *                             diese telematikID mit der telematikID im userCertificate
   *                             übereinstimmen. Bei unterschiedlichen telematikID wird die
   *                             Operation mit Fehlercode 422 abgelehnt. entryType Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) professionOID Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) usage         Kann optional
   *                             belegt werden. userCertificate   Kann optional belegt werden
   *                             (Format DER, Base64 kodiert) description   Kann optional belegt
   *                             werden. Entsprechend gemSpec_VZD wird ein Teil der Attribute durch
   *                             den Verzeichnisdienst automatisch mit Werten aus dem Zertifikat
   *                             gefüllt. Wenn in dieser Operation Attribute - für die dies erlaubt
   *                             ist - mit einem Wert belegt werden, wird dieser Wert im
   *                             Verzeichniseintrag gespeichert (auch wenn der Wert durch den
   *                             Verzeichnisdienst aus dem Zertifikat entnommen werden kann).
   *                             (required)
   * @return ApiResponse&lt;DistinguishedName&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public ApiResponse<DistinguishedName> addDirectoryEntryWithHttpInfo(
      CreateDirectoryEntry createDirectoryEntry) throws ApiException {
    okhttp3.Call localVarCall = addDirectoryEntryValidateBeforeCall(createDirectoryEntry, null);
    Type localVarReturnType = new TypeToken<DistinguishedName>() {
    }.getType();
    return localVarApiClient.execute(localVarCall, localVarReturnType);
  }

  /**
   * Einen Eintrag zum Verzeichnisdienst hinzufügen (asynchronously)
   *
   * @param createDirectoryEntry Datensatz für den neuen Eintrag. Die Attribute müssen wie folgt
   *                             belegt sein dn.*          Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) givenName     Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) sn Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) cn            Nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) displayName   Kann optional belegt
   *                             werden. streetAddress Kann optional belegt werden. postalCode
   *                             Kann optional belegt werden. countryCode   Kann optional belegt
   *                             werden. Falls nicht belegt, ergänzt der VZD den Code für
   *                             Deutschland (Defaultwert). localityName  Kann optional belegt
   *                             werden. stateOrProvinceName  Kann optional belegt werden. title
   *                                 Kann optional belegt werden. organization  Kann optional belegt
   *                             werden. otherName     Kann optional belegt werden. telematikID Kann
   *                             optional belegt werden. Das ist die telematikID in den Basisdaten
   *                             (baseDirectoryEntry). Wird diese telematikID und userCertificate
   *                             bzw. die telematikID in userCertificate angegeben, dann müssen
   *                             diese telematikIDs übereinstimmen. Bei unterschiedlichen
   *                             telematikID wird die Operation mit Fehlercode 422 abgelehnt.
   *                             specialization  Kann optional belegt werden. domainID      Kann
   *                             optional belegt werden. holder Kann optional belegt werden (falls
   *                             nicht belegt, dann vom VZD aus dem ID_Token entnommen). maxKOMLEadr
   *                               Kann optional belegt werden. personalEntry Nicht vorhanden (wird
   *                             vom Verzeichnisdienst belegt) dataFromAuthority Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) userCertificates  Kann optional
   *                             belegt werden. dn.uid Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) dn.dc         Leer/nicht vorhanden (wird
   *                             vom Verzeichnisdienst belegt) dn.ou Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst  belegt) dn.cn Leer/nicht vorhanden (wird vom
   *                             Verzeichnisdienst belegt) telematikID   Kann optional belegt
   *                             werden. Wird telematikID und userCertificate angegeben, dann muss
   *                             diese telematikID mit der telematikID im userCertificate
   *                             übereinstimmen. Bei unterschiedlichen telematikID wird die
   *                             Operation mit Fehlercode 422 abgelehnt. entryType Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) professionOID Nicht vorhanden
   *                             (wird vom Verzeichnisdienst belegt) usage         Kann optional
   *                             belegt werden. userCertificate   Kann optional belegt werden
   *                             (Format DER, Base64 kodiert) description   Kann optional belegt
   *                             werden. Entsprechend gemSpec_VZD wird ein Teil der Attribute durch
   *                             den Verzeichnisdienst automatisch mit Werten aus dem Zertifikat
   *                             gefüllt. Wenn in dieser Operation Attribute - für die dies erlaubt
   *                             ist - mit einem Wert belegt werden, wird dieser Wert im
   *                             Verzeichniseintrag gespeichert (auch wenn der Wert durch den
   *                             Verzeichnisdienst aus dem Zertifikat entnommen werden kann).
   *                             (required)
   * @param _callback            The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 201 </td><td> Created </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call addDirectoryEntryAsync(CreateDirectoryEntry createDirectoryEntry,
      final ApiCallback<DistinguishedName> _callback) throws ApiException {

    okhttp3.Call localVarCall = addDirectoryEntryValidateBeforeCall(createDirectoryEntry,
        _callback);
    Type localVarReturnType = new TypeToken<DistinguishedName>() {
    }.getType();
    localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
    return localVarCall;
  }

  /**
   * Build call for deleteDirectoryEntry
   *
   * @param uid       ID von dem zu löschenden Verzeichniseintrag Gelöscht werden der Basis
   *                  Verzeichniseintrag sowie alle dazugehörenden Zertifikate und Fachdaten.
   *                  (required)
   * @param _callback Callback for upload/download progress
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call deleteDirectoryEntryCall(String uid, final ApiCallback _callback)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/DirectoryEntries/{uid}"
        .replaceAll("\\{" + "uid" + "\\}", localVarApiClient.escapeString(uid.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();
    final String[] localVarAccepts = {
        "application/json"
    };
    final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) {
      localVarHeaderParams.put("Accept", localVarAccept);
    }

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = localVarApiClient.selectHeaderContentType(
        localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    String[] localVarAuthNames = new String[]{"OAuth2"};
    return localVarApiClient.buildCall(localVarPath, "DELETE", localVarQueryParams,
        localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams,
        localVarFormParams, localVarAuthNames, _callback);
  }

  @SuppressWarnings("rawtypes")
  private okhttp3.Call deleteDirectoryEntryValidateBeforeCall(String uid,
      final ApiCallback _callback) throws ApiException {

    // verify the required parameter 'uid' is set
    if (uid == null) {
      throw new ApiException(
          "Missing the required parameter 'uid' when calling deleteDirectoryEntry(Async)");
    }

    okhttp3.Call localVarCall = deleteDirectoryEntryCall(uid, _callback);
    return localVarCall;

  }

  /**
   * Gesamten Verzeichniseintrag löschen
   *
   * @param uid ID von dem zu löschenden Verzeichniseintrag Gelöscht werden der Basis
   *            Verzeichniseintrag sowie alle dazugehörenden Zertifikate und Fachdaten. (required)
   * @return Object
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public Object deleteDirectoryEntry(String uid) throws ApiException {
    ApiResponse<Object> localVarResp = deleteDirectoryEntryWithHttpInfo(uid);
    return localVarResp.getData();
  }

  /**
   * Gesamten Verzeichniseintrag löschen
   *
   * @param uid ID von dem zu löschenden Verzeichniseintrag Gelöscht werden der Basis
   *            Verzeichniseintrag sowie alle dazugehörenden Zertifikate und Fachdaten. (required)
   * @return ApiResponse&lt;Object&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public ApiResponse<Object> deleteDirectoryEntryWithHttpInfo(String uid) throws ApiException {
    okhttp3.Call localVarCall = deleteDirectoryEntryValidateBeforeCall(uid, null);
    Type localVarReturnType = new TypeToken<Object>() {
    }.getType();
    return localVarApiClient.execute(localVarCall, localVarReturnType);
  }

  /**
   * Gesamten Verzeichniseintrag löschen (asynchronously)
   *
   * @param uid       ID von dem zu löschenden Verzeichniseintrag Gelöscht werden der Basis
   *                  Verzeichniseintrag sowie alle dazugehörenden Zertifikate und Fachdaten.
   *                  (required)
   * @param _callback The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call deleteDirectoryEntryAsync(String uid, final ApiCallback<Object> _callback)
      throws ApiException {

    okhttp3.Call localVarCall = deleteDirectoryEntryValidateBeforeCall(uid, _callback);
    Type localVarReturnType = new TypeToken<Object>() {
    }.getType();
    localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
    return localVarCall;
  }

  /**
   * Build call for modifyDirectoryEntry
   *
   * @param uid                ID von dem Verzeichniseintrag (required)
   * @param baseDirectoryEntry Datensatz für die Aktualisierung des Eintrags Die Attribute müssen
   *                           wie folgt belegt sein dn.*          Nicht vorhanden (Adressierung
   *                           erfolgt über uid in Path). givenName     Nicht vorhanden. sn
   *                             Nicht vorhanden. cn Nicht vorhanden. displayName   Kann optional
   *                           belegt werden. streetAddress Kann optional belegt werden. postalCode
   *                           Kann optional belegt werden. countryCode   Kann optional belegt
   *                           werden. localityName  Kann optional belegt werden.
   *                           stateOrProvinceName  Kann optional belegt werden. title         Kann
   *                           optional belegt werden. organization  Kann optional belegt werden.
   *                           otherName     Nicht vorhanden. telematikID   Kann optional belegt
   *                           werden. Das ist die telematikID in den Basisdaten
   *                           (baseDirectoryEntry). Sind Zertifikateseinträge (userCertificate)
   *                           vorhanden, dann müssen die telematikIDs übereinstimmen. Bei
   *                           unterschiedlichen telematikID wird die Operation mit Fehlercode 422
   *                           abgelehnt. specialization  Kann optional belegt werden. domainID
   *                           Kann optional belegt werden. holder Kann optional belegt werden.
   *                           maxKOMLEadr   Kann optional belegt werden. personalEntry Nicht
   *                           vorhanden. dataFromAuthority Nicht vorhanden (required)
   * @param _callback          Callback for upload/download progress
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  * X-maxKOMLEadr-Limit -  <br>  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call modifyDirectoryEntryCall(String uid, BaseDirectoryEntry baseDirectoryEntry,
      final ApiCallback _callback) throws ApiException {
    Object localVarPostBody = baseDirectoryEntry;

    // create path and map variables
    String localVarPath = "/DirectoryEntries/{uid}/baseDirectoryEntries"
        .replaceAll("\\{" + "uid" + "\\}", localVarApiClient.escapeString(uid.toString()));

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();
    final String[] localVarAccepts = {
        "application/json"
    };
    final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) {
      localVarHeaderParams.put("Accept", localVarAccept);
    }

    final String[] localVarContentTypes = {
        "application/json"
    };
    final String localVarContentType = localVarApiClient.selectHeaderContentType(
        localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    String[] localVarAuthNames = new String[]{"OAuth2"};
    return localVarApiClient.buildCall(localVarPath, "PUT", localVarQueryParams,
        localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams,
        localVarFormParams, localVarAuthNames, _callback);
  }

  @SuppressWarnings("rawtypes")
  private okhttp3.Call modifyDirectoryEntryValidateBeforeCall(String uid,
      BaseDirectoryEntry baseDirectoryEntry, final ApiCallback _callback) throws ApiException {

    // verify the required parameter 'uid' is set
    if (uid == null) {
      throw new ApiException(
          "Missing the required parameter 'uid' when calling modifyDirectoryEntry(Async)");
    }

    // verify the required parameter 'baseDirectoryEntry' is set
    if (baseDirectoryEntry == null) {
      throw new ApiException(
          "Missing the required parameter 'baseDirectoryEntry' when calling modifyDirectoryEntry(Async)");
    }

    okhttp3.Call localVarCall = modifyDirectoryEntryCall(uid, baseDirectoryEntry, _callback);
    return localVarCall;

  }

  /**
   * Der Verzeichniseintrag (ohne Zertifikate und Fachdaten) wird mit den übergebenen Daten
   * aktualisiert.
   *
   * @param uid                ID von dem Verzeichniseintrag (required)
   * @param baseDirectoryEntry Datensatz für die Aktualisierung des Eintrags Die Attribute müssen
   *                           wie folgt belegt sein dn.*          Nicht vorhanden (Adressierung
   *                           erfolgt über uid in Path). givenName     Nicht vorhanden. sn
   *                             Nicht vorhanden. cn Nicht vorhanden. displayName   Kann optional
   *                           belegt werden. streetAddress Kann optional belegt werden. postalCode
   *                           Kann optional belegt werden. countryCode   Kann optional belegt
   *                           werden. localityName  Kann optional belegt werden.
   *                           stateOrProvinceName  Kann optional belegt werden. title         Kann
   *                           optional belegt werden. organization  Kann optional belegt werden.
   *                           otherName     Nicht vorhanden. telematikID   Kann optional belegt
   *                           werden. Das ist die telematikID in den Basisdaten
   *                           (baseDirectoryEntry). Sind Zertifikateseinträge (userCertificate)
   *                           vorhanden, dann müssen die telematikIDs übereinstimmen. Bei
   *                           unterschiedlichen telematikID wird die Operation mit Fehlercode 422
   *                           abgelehnt. specialization  Kann optional belegt werden. domainID
   *                           Kann optional belegt werden. holder Kann optional belegt werden.
   *                           maxKOMLEadr   Kann optional belegt werden. personalEntry Nicht
   *                           vorhanden. dataFromAuthority Nicht vorhanden (required)
   * @return DistinguishedName
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  * X-maxKOMLEadr-Limit -  <br>  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public DistinguishedName modifyDirectoryEntry(String uid, BaseDirectoryEntry baseDirectoryEntry)
      throws ApiException {
    ApiResponse<DistinguishedName> localVarResp = modifyDirectoryEntryWithHttpInfo(uid,
        baseDirectoryEntry);
    return localVarResp.getData();
  }

  /**
   * Der Verzeichniseintrag (ohne Zertifikate und Fachdaten) wird mit den übergebenen Daten
   * aktualisiert.
   *
   * @param uid                ID von dem Verzeichniseintrag (required)
   * @param baseDirectoryEntry Datensatz für die Aktualisierung des Eintrags Die Attribute müssen
   *                           wie folgt belegt sein dn.*          Nicht vorhanden (Adressierung
   *                           erfolgt über uid in Path). givenName     Nicht vorhanden. sn
   *                             Nicht vorhanden. cn Nicht vorhanden. displayName   Kann optional
   *                           belegt werden. streetAddress Kann optional belegt werden. postalCode
   *                           Kann optional belegt werden. countryCode   Kann optional belegt
   *                           werden. localityName  Kann optional belegt werden.
   *                           stateOrProvinceName  Kann optional belegt werden. title         Kann
   *                           optional belegt werden. organization  Kann optional belegt werden.
   *                           otherName     Nicht vorhanden. telematikID   Kann optional belegt
   *                           werden. Das ist die telematikID in den Basisdaten
   *                           (baseDirectoryEntry). Sind Zertifikateseinträge (userCertificate)
   *                           vorhanden, dann müssen die telematikIDs übereinstimmen. Bei
   *                           unterschiedlichen telematikID wird die Operation mit Fehlercode 422
   *                           abgelehnt. specialization  Kann optional belegt werden. domainID
   *                           Kann optional belegt werden. holder Kann optional belegt werden.
   *                           maxKOMLEadr   Kann optional belegt werden. personalEntry Nicht
   *                           vorhanden. dataFromAuthority Nicht vorhanden (required)
   * @return ApiResponse&lt;DistinguishedName&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  * X-maxKOMLEadr-Limit -  <br>  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public ApiResponse<DistinguishedName> modifyDirectoryEntryWithHttpInfo(String uid,
      BaseDirectoryEntry baseDirectoryEntry) throws ApiException {
    okhttp3.Call localVarCall = modifyDirectoryEntryValidateBeforeCall(uid, baseDirectoryEntry,
        null);
    Type localVarReturnType = new TypeToken<DistinguishedName>() {
    }.getType();
    return localVarApiClient.execute(localVarCall, localVarReturnType);
  }

  /**
   * Der Verzeichniseintrag (ohne Zertifikate und Fachdaten) wird mit den übergebenen Daten
   * aktualisiert. (asynchronously)
   *
   * @param uid                ID von dem Verzeichniseintrag (required)
   * @param baseDirectoryEntry Datensatz für die Aktualisierung des Eintrags Die Attribute müssen
   *                           wie folgt belegt sein dn.*          Nicht vorhanden (Adressierung
   *                           erfolgt über uid in Path). givenName     Nicht vorhanden. sn
   *                             Nicht vorhanden. cn Nicht vorhanden. displayName   Kann optional
   *                           belegt werden. streetAddress Kann optional belegt werden. postalCode
   *                           Kann optional belegt werden. countryCode   Kann optional belegt
   *                           werden. localityName  Kann optional belegt werden.
   *                           stateOrProvinceName  Kann optional belegt werden. title         Kann
   *                           optional belegt werden. organization  Kann optional belegt werden.
   *                           otherName     Nicht vorhanden. telematikID   Kann optional belegt
   *                           werden. Das ist die telematikID in den Basisdaten
   *                           (baseDirectoryEntry). Sind Zertifikateseinträge (userCertificate)
   *                           vorhanden, dann müssen die telematikIDs übereinstimmen. Bei
   *                           unterschiedlichen telematikID wird die Operation mit Fehlercode 422
   *                           abgelehnt. specialization  Kann optional belegt werden. domainID
   *                           Kann optional belegt werden. holder Kann optional belegt werden.
   *                           maxKOMLEadr   Kann optional belegt werden. personalEntry Nicht
   *                           vorhanden. dataFromAuthority Nicht vorhanden (required)
   * @param _callback          The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  * X-maxKOMLEadr-Limit -  <br>  </td></tr>
   * <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * <tr><td> 405 </td><td> Method Not Allowed </td><td>  -  </td></tr>
   * <tr><td> 422 </td><td> Unprocessable Entity </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call modifyDirectoryEntryAsync(String uid, BaseDirectoryEntry baseDirectoryEntry,
      final ApiCallback<DistinguishedName> _callback) throws ApiException {

    okhttp3.Call localVarCall = modifyDirectoryEntryValidateBeforeCall(uid, baseDirectoryEntry,
        _callback);
    Type localVarReturnType = new TypeToken<DistinguishedName>() {
    }.getType();
    localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
    return localVarCall;
  }

  /**
   * Build call for readDirectoryEntry
   *
   * @param uid                 ID von dem Verzeichniseintrag (distinguishedName.uid) (optional)
   * @param givenName           Erlaubt die Suche mit Hilfe des Attributs givenName. (optional)
   * @param sn                  Erlaubt die Suche mit Hilfe des Attributs sn. (optional)
   * @param cn                  Erlaubt die Suche mit Hilfe des Attributs cn. (optional)
   * @param displayName         Erlaubt die Suche mit Hilfe des Attributs displayName. (optional)
   * @param streetAddress       Erlaubt die Suche mit Hilfe des Attributs streetAddress. (optional)
   * @param postalCode          Erlaubt die Suche mit Hilfe des Attributs postalCode. (optional)
   * @param countryCode         Erlaubt die Suche mit Hilfe des Attributs countryCode. (optional)
   * @param localityName        Erlaubt die Suche mit Hilfe des Attributs localityName. (optional)
   * @param stateOrProvinceName Erlaubt die Suche mit Hilfe des Attributs stateOrProvinceName.
   *                            (optional)
   * @param title               Erlaubt die Suche mit Hilfe des Attributs title. (optional)
   * @param organization        Erlaubt die Suche mit Hilfe des Attributs organization. (optional)
   * @param otherName           Erlaubt die Suche mit Hilfe des Attributs otherName. (optional)
   * @param telematikID         Erlaubt die Suche mit Hilfe des Attributs telematikID (die
   *                            telematikID in den Basisdaten). (optional)
   * @param telematikIDSubStr   Erlaubt die Suche nach einem Substring am Anfang der telematikID
   *                            (die telematikID in den Basisdaten). Entspricht der LDAP Filters
   *                            Substring Assertion vom Typ \&quot;subInitial Component\&quot;.
   *                            (optional)
   * @param specialization      Erlaubt die Suche mit Hilfe des Attributs specialization. Der
   *                            Verzeichniseintrag wird selektiert, wenn die angegebene domainID im
   *                            Attribut domainID (array) des Verzeichniseintrags enthalten ist.
   *                            (optional)
   * @param domainID            Erlaubt die Suche mit Hilfe des Attributs domainID. Der
   *                            Verzeichniseintrag wird selektiert, wenn die angegebene domainID im
   *                            Attribut domainID (array) des Verzeichniseintrags enthalten ist.
   *                            (optional)
   * @param holder              Erlaubt die Suche mit Hilfe des Attributs holder. Der
   *                            Verzeichniseintrag wird selektiert, wenn der angegebene holder im
   *                            Attribut holder (array) des Verzeichniseintrags enthalten ist. Wenn
   *                            der Parameter mit dem eigenen Wert des Clients belegt wird, werden
   *                            alle gefundenen Einträge zurückgegeben (maximal 100 Einträge). Zur
   *                            Suche nach Einträge ohne holder ist der Parameter mit dem einem
   *                            leeren String \&quot;\&quot; zu belegen. Auch in diesem Fall werden
   *                            alle gefundenen Einträge zurückgegeben (maximal 100 Einträge).
   *                            (optional)
   * @param personalEntry       Erlaubt die Suche mit Hilfe des Attributs personalEntry. (optional)
   * @param dataFromAuthority   Erlaubt die Suche mit Hilfe des Attributs dataFromAuthority.
   *                            (optional)
   * @param professionOID       Erlaubt die Suche mit Hilfe des Attributs professionOID. Selektiert
   *                            der Verzeichniseintrag, wenn der angegebene Wert in den
   *                            professionOID&#39;s (array) des Basiseintrags vorhanden ist.
   *                            (optional)
   * @param entryType           Erlaubt die Suche mit Hilfe des Attributs entryType. Selektiert der
   *                            Verzeichniseintrag, wenn der angegebene Wert in den entryType&#39;s
   *                            (array) des Basiseintrags vorhanden ist. (optional)
   * @param baseEntryOnly       Mit baseEntryOnly &#x3D; \&quot;true\&quot; wird nur der
   *                            Basiseintrag (baseDirectoryEntry) im Response zurückgegeben. Falls
   *                            nicht angegeben oder mit \&quot;false\&quot; belegt, wird der
   *                            gesamte Verzeichniseintrag mit Zertifikaten und Fachdaten im
   *                            Response zurückgegeben. (optional)
   * @param _callback           Callback for upload/download progress
   * @return Call to execute
   * @throws ApiException If fail to serialize the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call readDirectoryEntryCall(String uid, String givenName, String sn, String cn,
      String displayName, String streetAddress, String postalCode, String countryCode,
      String localityName, String stateOrProvinceName, String title, String organization,
      String otherName, String telematikID, String telematikIDSubStr, String specialization,
      String domainID, String holder, String personalEntry, String dataFromAuthority,
      String professionOID, String entryType, Boolean baseEntryOnly, final ApiCallback _callback)
      throws ApiException {
    Object localVarPostBody = null;

    // create path and map variables
    String localVarPath = "/DirectoryEntries";

    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    if (uid != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("uid", uid));
    }

    if (givenName != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("givenName", givenName));
    }

    if (sn != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("sn", sn));
    }

    if (cn != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("cn", cn));
    }

    if (displayName != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("displayName", displayName));
    }

    if (streetAddress != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("streetAddress", streetAddress));
    }

    if (postalCode != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("postalCode", postalCode));
    }

    if (countryCode != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("countryCode", countryCode));
    }

    if (localityName != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("localityName", localityName));
    }

    if (stateOrProvinceName != null) {
      localVarQueryParams.addAll(
          localVarApiClient.parameterToPair("stateOrProvinceName", stateOrProvinceName));
    }

    if (title != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("title", title));
    }

    if (organization != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("organization", organization));
    }

    if (otherName != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("otherName", otherName));
    }

    if (telematikID != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("telematikID", telematikID));
    }

    if (telematikIDSubStr != null) {
      localVarQueryParams.addAll(
          localVarApiClient.parameterToPair("telematikID-SubStr", telematikIDSubStr));
    }

    if (specialization != null) {
      localVarQueryParams.addAll(
          localVarApiClient.parameterToPair("specialization", specialization));
    }

    if (domainID != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("domainID", domainID));
    }

    if (holder != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("holder", holder));
    }

    if (personalEntry != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("personalEntry", personalEntry));
    }

    if (dataFromAuthority != null) {
      localVarQueryParams.addAll(
          localVarApiClient.parameterToPair("dataFromAuthority", dataFromAuthority));
    }

    if (professionOID != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("professionOID", professionOID));
    }

    if (entryType != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("entryType", entryType));
    }

    if (baseEntryOnly != null) {
      localVarQueryParams.addAll(localVarApiClient.parameterToPair("baseEntryOnly", baseEntryOnly));
    }

    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();
    final String[] localVarAccepts = {
        "application/json"
    };
    final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
    if (localVarAccept != null) {
      localVarHeaderParams.put("Accept", localVarAccept);
    }

    final String[] localVarContentTypes = {

    };
    final String localVarContentType = localVarApiClient.selectHeaderContentType(
        localVarContentTypes);
    localVarHeaderParams.put("Content-Type", localVarContentType);

    String[] localVarAuthNames = new String[]{"OAuth2"};
    return localVarApiClient.buildCall(localVarPath, "GET", localVarQueryParams,
        localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams,
        localVarFormParams, localVarAuthNames, _callback);
  }

  @SuppressWarnings("rawtypes")
  private okhttp3.Call readDirectoryEntryValidateBeforeCall(String uid, String givenName, String sn,
      String cn, String displayName, String streetAddress, String postalCode, String countryCode,
      String localityName, String stateOrProvinceName, String title, String organization,
      String otherName, String telematikID, String telematikIDSubStr, String specialization,
      String domainID, String holder, String personalEntry, String dataFromAuthority,
      String professionOID, String entryType, Boolean baseEntryOnly, final ApiCallback _callback)
      throws ApiException {

    okhttp3.Call localVarCall = readDirectoryEntryCall(uid, givenName, sn, cn, displayName,
        streetAddress, postalCode, countryCode, localityName, stateOrProvinceName, title,
        organization, otherName, telematikID, telematikIDSubStr, specialization, domainID, holder,
        personalEntry, dataFromAuthority, professionOID, entryType, baseEntryOnly, _callback);
    return localVarCall;

  }

  /**
   * Gesamten Verzeichniseintrag lesen Liefert alle zum Filter passenden Verzeichniseinträge
   * (maximal 100 Einträge). Die angegebenen Parameter werden mit logischen UND verknüpft.
   *
   * @param uid                 ID von dem Verzeichniseintrag (distinguishedName.uid) (optional)
   * @param givenName           Erlaubt die Suche mit Hilfe des Attributs givenName. (optional)
   * @param sn                  Erlaubt die Suche mit Hilfe des Attributs sn. (optional)
   * @param cn                  Erlaubt die Suche mit Hilfe des Attributs cn. (optional)
   * @param displayName         Erlaubt die Suche mit Hilfe des Attributs displayName. (optional)
   * @param streetAddress       Erlaubt die Suche mit Hilfe des Attributs streetAddress. (optional)
   * @param postalCode          Erlaubt die Suche mit Hilfe des Attributs postalCode. (optional)
   * @param countryCode         Erlaubt die Suche mit Hilfe des Attributs countryCode. (optional)
   * @param localityName        Erlaubt die Suche mit Hilfe des Attributs localityName. (optional)
   * @param stateOrProvinceName Erlaubt die Suche mit Hilfe des Attributs stateOrProvinceName.
   *                            (optional)
   * @param title               Erlaubt die Suche mit Hilfe des Attributs title. (optional)
   * @param organization        Erlaubt die Suche mit Hilfe des Attributs organization. (optional)
   * @param otherName           Erlaubt die Suche mit Hilfe des Attributs otherName. (optional)
   * @param telematikID         Erlaubt die Suche mit Hilfe des Attributs telematikID (die
   *                            telematikID in den Basisdaten). (optional)
   * @param telematikIDSubStr   Erlaubt die Suche nach einem Substring am Anfang der telematikID
   *                            (die telematikID in den Basisdaten). Entspricht der LDAP Filters
   *                            Substring Assertion vom Typ \&quot;subInitial Component\&quot;.
   *                            (optional)
   * @param specialization      Erlaubt die Suche mit Hilfe des Attributs specialization. Der
   *                            Verzeichniseintrag wird selektiert, wenn die angegebene domainID im
   *                            Attribut domainID (array) des Verzeichniseintrags enthalten ist.
   *                            (optional)
   * @param domainID            Erlaubt die Suche mit Hilfe des Attributs domainID. Der
   *                            Verzeichniseintrag wird selektiert, wenn die angegebene domainID im
   *                            Attribut domainID (array) des Verzeichniseintrags enthalten ist.
   *                            (optional)
   * @param holder              Erlaubt die Suche mit Hilfe des Attributs holder. Der
   *                            Verzeichniseintrag wird selektiert, wenn der angegebene holder im
   *                            Attribut holder (array) des Verzeichniseintrags enthalten ist. Wenn
   *                            der Parameter mit dem eigenen Wert des Clients belegt wird, werden
   *                            alle gefundenen Einträge zurückgegeben (maximal 100 Einträge). Zur
   *                            Suche nach Einträge ohne holder ist der Parameter mit dem einem
   *                            leeren String \&quot;\&quot; zu belegen. Auch in diesem Fall werden
   *                            alle gefundenen Einträge zurückgegeben (maximal 100 Einträge).
   *                            (optional)
   * @param personalEntry       Erlaubt die Suche mit Hilfe des Attributs personalEntry. (optional)
   * @param dataFromAuthority   Erlaubt die Suche mit Hilfe des Attributs dataFromAuthority.
   *                            (optional)
   * @param professionOID       Erlaubt die Suche mit Hilfe des Attributs professionOID. Selektiert
   *                            der Verzeichniseintrag, wenn der angegebene Wert in den
   *                            professionOID&#39;s (array) des Basiseintrags vorhanden ist.
   *                            (optional)
   * @param entryType           Erlaubt die Suche mit Hilfe des Attributs entryType. Selektiert der
   *                            Verzeichniseintrag, wenn der angegebene Wert in den entryType&#39;s
   *                            (array) des Basiseintrags vorhanden ist. (optional)
   * @param baseEntryOnly       Mit baseEntryOnly &#x3D; \&quot;true\&quot; wird nur der
   *                            Basiseintrag (baseDirectoryEntry) im Response zurückgegeben. Falls
   *                            nicht angegeben oder mit \&quot;false\&quot; belegt, wird der
   *                            gesamte Verzeichniseintrag mit Zertifikaten und Fachdaten im
   *                            Response zurückgegeben. (optional)
   * @return List&lt;DirectoryEntry&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public List<DirectoryEntry> readDirectoryEntry(String uid, String givenName, String sn, String cn,
      String displayName, String streetAddress, String postalCode, String countryCode,
      String localityName, String stateOrProvinceName, String title, String organization,
      String otherName, String telematikID, String telematikIDSubStr, String specialization,
      String domainID, String holder, String personalEntry, String dataFromAuthority,
      String professionOID, String entryType, Boolean baseEntryOnly) throws ApiException {
    ApiResponse<List<DirectoryEntry>> localVarResp = readDirectoryEntryWithHttpInfo(uid, givenName,
        sn, cn, displayName, streetAddress, postalCode, countryCode, localityName,
        stateOrProvinceName, title, organization, otherName, telematikID, telematikIDSubStr,
        specialization, domainID, holder, personalEntry, dataFromAuthority, professionOID,
        entryType, baseEntryOnly);
    return localVarResp.getData();
  }

  /**
   * Gesamten Verzeichniseintrag lesen Liefert alle zum Filter passenden Verzeichniseinträge
   * (maximal 100 Einträge). Die angegebenen Parameter werden mit logischen UND verknüpft.
   *
   * @param uid                 ID von dem Verzeichniseintrag (distinguishedName.uid) (optional)
   * @param givenName           Erlaubt die Suche mit Hilfe des Attributs givenName. (optional)
   * @param sn                  Erlaubt die Suche mit Hilfe des Attributs sn. (optional)
   * @param cn                  Erlaubt die Suche mit Hilfe des Attributs cn. (optional)
   * @param displayName         Erlaubt die Suche mit Hilfe des Attributs displayName. (optional)
   * @param streetAddress       Erlaubt die Suche mit Hilfe des Attributs streetAddress. (optional)
   * @param postalCode          Erlaubt die Suche mit Hilfe des Attributs postalCode. (optional)
   * @param countryCode         Erlaubt die Suche mit Hilfe des Attributs countryCode. (optional)
   * @param localityName        Erlaubt die Suche mit Hilfe des Attributs localityName. (optional)
   * @param stateOrProvinceName Erlaubt die Suche mit Hilfe des Attributs stateOrProvinceName.
   *                            (optional)
   * @param title               Erlaubt die Suche mit Hilfe des Attributs title. (optional)
   * @param organization        Erlaubt die Suche mit Hilfe des Attributs organization. (optional)
   * @param otherName           Erlaubt die Suche mit Hilfe des Attributs otherName. (optional)
   * @param telematikID         Erlaubt die Suche mit Hilfe des Attributs telematikID (die
   *                            telematikID in den Basisdaten). (optional)
   * @param telematikIDSubStr   Erlaubt die Suche nach einem Substring am Anfang der telematikID
   *                            (die telematikID in den Basisdaten). Entspricht der LDAP Filters
   *                            Substring Assertion vom Typ \&quot;subInitial Component\&quot;.
   *                            (optional)
   * @param specialization      Erlaubt die Suche mit Hilfe des Attributs specialization. Der
   *                            Verzeichniseintrag wird selektiert, wenn die angegebene domainID im
   *                            Attribut domainID (array) des Verzeichniseintrags enthalten ist.
   *                            (optional)
   * @param domainID            Erlaubt die Suche mit Hilfe des Attributs domainID. Der
   *                            Verzeichniseintrag wird selektiert, wenn die angegebene domainID im
   *                            Attribut domainID (array) des Verzeichniseintrags enthalten ist.
   *                            (optional)
   * @param holder              Erlaubt die Suche mit Hilfe des Attributs holder. Der
   *                            Verzeichniseintrag wird selektiert, wenn der angegebene holder im
   *                            Attribut holder (array) des Verzeichniseintrags enthalten ist. Wenn
   *                            der Parameter mit dem eigenen Wert des Clients belegt wird, werden
   *                            alle gefundenen Einträge zurückgegeben (maximal 100 Einträge). Zur
   *                            Suche nach Einträge ohne holder ist der Parameter mit dem einem
   *                            leeren String \&quot;\&quot; zu belegen. Auch in diesem Fall werden
   *                            alle gefundenen Einträge zurückgegeben (maximal 100 Einträge).
   *                            (optional)
   * @param personalEntry       Erlaubt die Suche mit Hilfe des Attributs personalEntry. (optional)
   * @param dataFromAuthority   Erlaubt die Suche mit Hilfe des Attributs dataFromAuthority.
   *                            (optional)
   * @param professionOID       Erlaubt die Suche mit Hilfe des Attributs professionOID. Selektiert
   *                            der Verzeichniseintrag, wenn der angegebene Wert in den
   *                            professionOID&#39;s (array) des Basiseintrags vorhanden ist.
   *                            (optional)
   * @param entryType           Erlaubt die Suche mit Hilfe des Attributs entryType. Selektiert der
   *                            Verzeichniseintrag, wenn der angegebene Wert in den entryType&#39;s
   *                            (array) des Basiseintrags vorhanden ist. (optional)
   * @param baseEntryOnly       Mit baseEntryOnly &#x3D; \&quot;true\&quot; wird nur der
   *                            Basiseintrag (baseDirectoryEntry) im Response zurückgegeben. Falls
   *                            nicht angegeben oder mit \&quot;false\&quot; belegt, wird der
   *                            gesamte Verzeichniseintrag mit Zertifikaten und Fachdaten im
   *                            Response zurückgegeben. (optional)
   * @return ApiResponse&lt;List&lt;DirectoryEntry&gt;&gt;
   * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
   *                      response body
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public ApiResponse<List<DirectoryEntry>> readDirectoryEntryWithHttpInfo(String uid,
      String givenName, String sn, String cn, String displayName, String streetAddress,
      String postalCode, String countryCode, String localityName, String stateOrProvinceName,
      String title, String organization, String otherName, String telematikID,
      String telematikIDSubStr, String specialization, String domainID, String holder,
      String personalEntry, String dataFromAuthority, String professionOID, String entryType,
      Boolean baseEntryOnly) throws ApiException {
    okhttp3.Call localVarCall = readDirectoryEntryValidateBeforeCall(uid, givenName, sn, cn,
        displayName, streetAddress, postalCode, countryCode, localityName, stateOrProvinceName,
        title, organization, otherName, telematikID, telematikIDSubStr, specialization, domainID,
        holder, personalEntry, dataFromAuthority, professionOID, entryType, baseEntryOnly, null);
    Type localVarReturnType = new TypeToken<List<DirectoryEntry>>() {
    }.getType();
    return localVarApiClient.execute(localVarCall, localVarReturnType);
  }

  /**
   * Gesamten Verzeichniseintrag lesen (asynchronously) Liefert alle zum Filter passenden
   * Verzeichniseinträge (maximal 100 Einträge). Die angegebenen Parameter werden mit logischen UND
   * verknüpft.
   *
   * @param uid                 ID von dem Verzeichniseintrag (distinguishedName.uid) (optional)
   * @param givenName           Erlaubt die Suche mit Hilfe des Attributs givenName. (optional)
   * @param sn                  Erlaubt die Suche mit Hilfe des Attributs sn. (optional)
   * @param cn                  Erlaubt die Suche mit Hilfe des Attributs cn. (optional)
   * @param displayName         Erlaubt die Suche mit Hilfe des Attributs displayName. (optional)
   * @param streetAddress       Erlaubt die Suche mit Hilfe des Attributs streetAddress. (optional)
   * @param postalCode          Erlaubt die Suche mit Hilfe des Attributs postalCode. (optional)
   * @param countryCode         Erlaubt die Suche mit Hilfe des Attributs countryCode. (optional)
   * @param localityName        Erlaubt die Suche mit Hilfe des Attributs localityName. (optional)
   * @param stateOrProvinceName Erlaubt die Suche mit Hilfe des Attributs stateOrProvinceName.
   *                            (optional)
   * @param title               Erlaubt die Suche mit Hilfe des Attributs title. (optional)
   * @param organization        Erlaubt die Suche mit Hilfe des Attributs organization. (optional)
   * @param otherName           Erlaubt die Suche mit Hilfe des Attributs otherName. (optional)
   * @param telematikID         Erlaubt die Suche mit Hilfe des Attributs telematikID (die
   *                            telematikID in den Basisdaten). (optional)
   * @param telematikIDSubStr   Erlaubt die Suche nach einem Substring am Anfang der telematikID
   *                            (die telematikID in den Basisdaten). Entspricht der LDAP Filters
   *                            Substring Assertion vom Typ \&quot;subInitial Component\&quot;.
   *                            (optional)
   * @param specialization      Erlaubt die Suche mit Hilfe des Attributs specialization. Der
   *                            Verzeichniseintrag wird selektiert, wenn die angegebene domainID im
   *                            Attribut domainID (array) des Verzeichniseintrags enthalten ist.
   *                            (optional)
   * @param domainID            Erlaubt die Suche mit Hilfe des Attributs domainID. Der
   *                            Verzeichniseintrag wird selektiert, wenn die angegebene domainID im
   *                            Attribut domainID (array) des Verzeichniseintrags enthalten ist.
   *                            (optional)
   * @param holder              Erlaubt die Suche mit Hilfe des Attributs holder. Der
   *                            Verzeichniseintrag wird selektiert, wenn der angegebene holder im
   *                            Attribut holder (array) des Verzeichniseintrags enthalten ist. Wenn
   *                            der Parameter mit dem eigenen Wert des Clients belegt wird, werden
   *                            alle gefundenen Einträge zurückgegeben (maximal 100 Einträge). Zur
   *                            Suche nach Einträge ohne holder ist der Parameter mit dem einem
   *                            leeren String \&quot;\&quot; zu belegen. Auch in diesem Fall werden
   *                            alle gefundenen Einträge zurückgegeben (maximal 100 Einträge).
   *                            (optional)
   * @param personalEntry       Erlaubt die Suche mit Hilfe des Attributs personalEntry. (optional)
   * @param dataFromAuthority   Erlaubt die Suche mit Hilfe des Attributs dataFromAuthority.
   *                            (optional)
   * @param professionOID       Erlaubt die Suche mit Hilfe des Attributs professionOID. Selektiert
   *                            der Verzeichniseintrag, wenn der angegebene Wert in den
   *                            professionOID&#39;s (array) des Basiseintrags vorhanden ist.
   *                            (optional)
   * @param entryType           Erlaubt die Suche mit Hilfe des Attributs entryType. Selektiert der
   *                            Verzeichniseintrag, wenn der angegebene Wert in den entryType&#39;s
   *                            (array) des Basiseintrags vorhanden ist. (optional)
   * @param baseEntryOnly       Mit baseEntryOnly &#x3D; \&quot;true\&quot; wird nur der
   *                            Basiseintrag (baseDirectoryEntry) im Response zurückgegeben. Falls
   *                            nicht angegeben oder mit \&quot;false\&quot; belegt, wird der
   *                            gesamte Verzeichniseintrag mit Zertifikaten und Fachdaten im
   *                            Response zurückgegeben. (optional)
   * @param _callback           The callback to be executed when the API call finishes
   * @return The request call
   * @throws ApiException If fail to process the API call, e.g. serializing the request body object
   * @http.response.details <table summary="Response Details" border="1">
   * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
   * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
   * <tr><td> 401 </td><td> Unauthorized </td><td>  -  </td></tr>
   * <tr><td> 403 </td><td> Forbidden </td><td>  -  </td></tr>
   * <tr><td> 404 </td><td> Not Found </td><td>  -  </td></tr>
   * </table>
   */
  public okhttp3.Call readDirectoryEntryAsync(String uid, String givenName, String sn, String cn,
      String displayName, String streetAddress, String postalCode, String countryCode,
      String localityName, String stateOrProvinceName, String title, String organization,
      String otherName, String telematikID, String telematikIDSubStr, String specialization,
      String domainID, String holder, String personalEntry, String dataFromAuthority,
      String professionOID, String entryType, Boolean baseEntryOnly,
      final ApiCallback<List<DirectoryEntry>> _callback) throws ApiException {

    okhttp3.Call localVarCall = readDirectoryEntryValidateBeforeCall(uid, givenName, sn, cn,
        displayName, streetAddress, postalCode, countryCode, localityName, stateOrProvinceName,
        title, organization, otherName, telematikID, telematikIDSubStr, specialization, domainID,
        holder, personalEntry, dataFromAuthority, professionOID, entryType, baseEntryOnly,
        _callback);
    Type localVarReturnType = new TypeToken<List<DirectoryEntry>>() {
    }.getType();
    localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
    return localVarCall;
  }
}
